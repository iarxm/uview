#!/usr/bin/env bash

# ######################################################
# AUTHOR: IAROM MADDEN
#
# file preview via tabbed xembed with persistent preview file state
# files are sent to previewer via interface/server method
# dep: tabbed mpv neovim zathura prg_nuk
# tabbed configured w relative tabs and new pos = 1
#
# ########################################################

# todo: initialise prgs 
# todo: refactor whole program
# todo: 4th tab w. prg_nuk
# todo: wm focus control

###########################################################

# init config [TODO:set in a config file]

cache_dir="$HOME/.cache/uview"
prg_nuk="${XDG_CONFIG_HOME:-$HOME/.config}/nnn/plugins/prg_nuk"
prg_trm="st -c preview -w"
prg_pgr=${prg_pgr:-"nvim -R"}
tab_mpv="1"
tab_nvi="2"
tab_zat="3"
tim_lim="0.1"


# init universals

fifox="$1"

_ini_var() {
  
  fil_one="$nnn"
  fil_cur="$fil_one"
  { [ -n "$fifox" ] && [ -f "$NNN_FIFO" ]; } && fifox="$NNN_FIFO"
  fifoy=""
  
  mkdir -p "$cache_dir"
  cac_tim_swi="$cache_dir/cache.tim_swi"
  cac_fil_cur="$cache_dir/cache.fil_cur"

  printf "y" > "$cac_tim_swi" # add this into a 'init' function
  
  [ -n "$MPVX" ] && mpv="$MPVX" || mpv="mpv"
  mim_las="application/pdf" # first visible win is zath
  mim_cur=""
  
  xid_tbd=""
  pid_tbd=""
  soc_mpv=""
  soc_nvi=""
  soc_zat=""
  
  log_x="$cache_dir/uviewx.log"
  log_y="$cache_dir/uviewy.log"
  #pid_view=""
}


# atoms ########################################

_prn()             { printf "%s \n" "$@"; }
_set_mim_cur()     { mim_cur=$(file -bL --mime-type "${fil_cur}"); }
_win_foc_tab()     { xdotool key --window "$xid_tbd" "Ctrl+$1";  _win_foc_main; }
_tst_fif()         { [ ! -r "$fifox" ] && { echo "fifox read fail ($fifox)"; exit 1; }; }
_set_cac_fil_cur() { _prn "$fil_cur" > "$cac_fil_cur"; }
_debugx()          { _prn "$1" >> "$log_x" ; }

_set_trm() { 
  if which $prg_trm >/dev/null 2>&1 ; then
    prg_trm=$prg_trm
  elif which st >/dev/null 2>&1 ; then
    prg_trm="st -c preview -w"
  elif which urxvt >/dev/null 2>&1 ; then
    prg_trm="urxvt -embed"
  elif which xterm >/dev/null 2>&1 ; then
    prg_trm="xterm -into"
  else
    _prn "no xembed term found" >&2
  fi ;}

_trm_prg_nuk ()  { $prg_trm "$xid_tbd" -e "$prg_nuk" "$fil_cur" & }


# mpv #####################################

_mpv_ini() { $mpv --input-ipc-server="${soc_mpv}" --wid="$xid_tbd" --focus-on=never --force-window=immediate --idle "${fil_cur}" & }

_mpv_add() { printf '%s\n' "{ \"command\": [\"loadfile\", \"$fil_cur\", \"replace\" ] }" | socat - "${soc_mpv}" &> /dev/null; }

_mpv() { _mpv_add ;}


# nvim #######################################

_nvi_ini() { $prg_trm "$xid_tbd" -e nvim --listen "${soc_nvi}" -c 'set shortmess+=I | hi CursorLine guibg=black guifg=black' & }

_nvi_snd() { 
  case $mim_cur in
    text/*)           ncmd=":view ${fil_cur}<CR>" ;;
    inode/directory)  ncmd=":view ${fil_cur}/<CR>" ;;
  esac
  nvim --server "${soc_nvi}" --remote-send "$ncmd" & }

_nvi() {
  pid_nvi="$(pgrep -f "nvim --listen ${soc_nvi}")"
  { [ -n "${pid_nvi}" ] && _nvi_snd; } \
    || { _nvi_ini; _nvi_snd; }; }


# zat #########################################

_soc_prn_zat() {
  dbus-send \
    --session \
    --dest=org.freedesktop.DBus \
    --type=method_call          \
    --print-reply               \
    /org/freedesktop/DBus       \
    org.freedesktop.DBus.ListNames | sed -nr '/^.*string "(.*zathura.*)"/{s//\1/p;q;}' ;}

_kil_zat() { [ -n "$soc_zat" ] && kill -9 "$(echo "$soc_zat" | sed -n 's/.*PID-\([0-9]\+\).*/\1/p')"; }

_soc_set_zat () { sleep 1; soc_zat="$(_soc_prn_zat)" ; }

_zat_snd() { # open file
  _debugx "zat send; soc_zat: $soc_zat"
  dbus-send \
    --session  \
    --dest="$soc_zat"  \
    --type=method_call \
    --print-reply      \
    /org/pwmt/zathura  \
    org.pwmt.zathura.OpenDocument \
    string:"${fil_cur}" \
    string:'' \
    int32:1 &2>> /dev/null ; }

    #int32:1 2>&1 >> $log_y ; }
    #string:\'"${fil_cur}"\' \
    #TODO: issues with some filenames
    #TODO: events that respond to errors (eg respawn zath and init)

_zat_ini() { 
  zathura -e "$xid_tbd" "$fil_cur" &
  _soc_set_zat ;}

_zat() { [ -n "$(_soc_prn_zat)" ] && [ -n "${soc_zat}" ] && { _zat_snd & return; }; _zat_ini ;} # inefficient. improvements?


# mime handling #############################

_mim_handlers() {
  if which mpv >/dev/null 2>&1 ; then
    media() { _mpv; } else
    media() { _trm_prg_nuk; } fi
  if which zathura >/dev/null 2>&1 ; then
    doc()   { _zat; }; else
    doc()   { _trm_prg_nuk; }; fi
  if which nvim >/dev/null 2>&1 ; then
    txtp()  { _nvi; }
    inodev(){ _nvi; }; else
    txtp()  { _trm_prg_nuk; }; fi ;}

_mim_switch() { # mime switches
  [ n = $(cat "$cac_tim_swi") ] && return
  case "$mim_cur" in
    video/*)                  media ;;
    application/octet-stream) media ;;
    audio/*)                  media ;;
    image/*)                  media ;;
    application/pdf)          doc ;;
    inode/directory)          inodev ;;
    text/*)                   txtp ;;
    #*) all ;;
  esac ;}


# tabbed ########################################

_prg_tbd_ini () { # start tabbed
    fifoy="$(mktemp -u)"
    mkfifo "$fifoy"
    tabbed -n preview > "$fifoy" &

    jobs
    pid_tbd="$(jobs -p %%)"
    fif_nnn="$(echo $fifox | grep -o '[0-9]\+')"
    soc_mpv="/tmp/nnn.${fif_nnn}.tbd-${pid_tbd}.mpv"
    soc_nvi="/tmp/nnn.${fif_nnn}.tbd-${pid_tbd}.nvi"

    [ -z "$pid_tbd" ] && { echo "Can't start tabbed"; exit 1; }
    read -r xid_tbd < "$fifoy" && rm "$fifoy"
   
    _mpv_ini & sleep 1.9
    _nvi_ini & sleep 1
    _zat_ini
  }


# focus switches #########################################

_foc_viewer() { # sol to grab foc of background tabs? #TODO: work in progress
  [ $mim_cur = $mim_las ] && return

  case $mim_cur in
    video/*|image/*|audio/*) _win_foc_tab $tab_mpv ;;
    text/*|inode/*)          _win_foc_tab $tab_nvi ;;
    application/pdf)         _win_foc_tab $tab_zat ;;
  esac ;}

_tim_swi() { _prn "$1" > "$cac_tim_swi"; }

_tim() {
  fil_new="${fil_cur}"
  _tim_swi "n" # turn off
  sleep "$tim_lim"
  fil_upd="$(cat "$cac_fil_cur")"
  [ $fil_new = $fil_upd ] && _tim_swi "y" && return ;}
 

# viewing - kill #######################################

_kill_viewer() { # viewer
  # if last was vid/txt/node: { curm = lastm -> return || otherwise kill }
  _mime_test_curr
  _mime_test_last
  [ -n "$is_last_media"  ] && return
  [ -n "$is_last_vim"  ] && return
  [ -n "$is_last_doc"  ] && return
  #[ -n "$is_last_media"  ] && [ -n "$is_curr_media" ] && return
  #[ -n "$is_last_vim"  ] && [ -n "$is_curr_vim" ] && return
  #[ -n "$is_last_doc"  ] && [ -n "$is_curr_doc" ] && return
  #_kill_nvim 
  #_kill_mpv
  _kill_viewer_pid ; }


# Cleanup #####################################################

_kil()     { kill "$pid_tbd"; rm -f "$soc_mpv" "$soc_nvi"; _kil_zat; disown; exit 0 ; }


# body - init ########################################################

_ini() { # init sigs
  _ini_var
  _tst_fif
  _set_trm
  exec >/dev/null 2>&1  # mute from now
  trap _kill_all SIGINT

  # init tabbed
  #_set_xid_tbd
  _prg_tbd_ini
  #_win_foc_nnn &

  # init handles
  _mim_handlers
  _set_cac_fil_cur
  _set_mim_cur
  }


# main #####################################################

_main() { # init new file arg
  _ini

  while read -r fil_cur ; do
    jobs
    if ! jobs | grep tabbed ; then 
      break
    fi

    [ ! -e "$fil_cur" ] && continue
    _set_cac_fil_cur
    _set_mim_cur
  
    _foc_viewer
    _mim_switch 
    _tim &
    _debug "done"
  
    mim_las="${mim_cur}"
    #_win_foc

  done < "$fifox"
  
  _kil; }


_main &

